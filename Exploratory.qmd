---
title: "Data Exploration"
author: "Hope Donoghue"
format: html
---

```{r}
library(readr)
goalscorers <- read_csv("archive/goalscorers.csv")
results <- read_csv("archive/results.csv")
shootouts <- read_csv("archive/shootouts.csv")
```

```{r}
devtools::install_github("statsbomb/StatsBombR")
```

Using event data to create an expected goals model with machine learning techniques for NWSL women's soccer

Inspiration a blog for expected goals model: https://www.gopalakrishnan.me/2019/04/17/xg/

https://statsbomb.com/soccer-metrics/expected-goals-xg-explained/ 

- Goals talk about the results of the shots taken in a game as expected goals talk about the quality of the shots taken in the game and it assigns a value (xG) to each shot, which is the probability of that shot resulting in a goal. Higher xG, means higher chance of a shot becoming a goal. 

- An xG model uses historical information from thousands of shots with similar characteristics to estimate the likelihood of a goal on a scale between 0 and 1.
For example, a shot with an xG value of 0.2 is one that we would generally expect to be converted twice in every 10 attempts.

How is xG calculated?
- Each xG model has its own characteristics, but the main factors are distance to goal, angle to goal, body part with which the shot was taken an take of assist or previous action. 

What have xG models taught us?
- Central shots are best (shots from the central part of the penalty area are more valuable than those from tighter areas)
- Feet over head: from the same distance, foot shots are more likely to result in goals than headed shots. 
- Crosses are more difficult to convert than ground passes


```{r}
library(dbplyr) # database access
library(DBI) # database access
library(tidyverse) # dataframe manipulation
library(tidymodels) # data processing and modeling

#source("../data/pitch_plots.r") # helper function to plot the pitch
```

```{r}
library(StatsBombR)
Comp = FreeCompetitions()
Matches = FreeMatches(Comp)

#Getting data only for the nwsl league
womens_matches_nwsl <- Matches %>%
  filter(home_team.home_team_gender == "female") %>%
  filter(competition.competition_name == "NWSL")
  
# see the first match of data only 
first_match <- get.matchFree(womens_matches_nwsl[1,])

error_game = nrow(Matches) - 39
all_events = data.frame()
for(i in 1:nrow(womens_matches_nwsl)){
  #if(i %in% c(error_game)) next
  temp = get.matchFree(womens_matches_nwsl[i,])
  print(i)
  temp = allclean(temp)
  all_events = bind_rows(all_events, temp)
  rm(temp)
}
```

```{r}
shots <- all_events %>%
  filter(type.name == "Shot") %>%
  mutate(is.goal = ifelse(shot.outcome.name == "Goal", "Goal", "NoGoal"))
```


```{r}
# Plotting all the shots in the NWSL season
library(tidyr)
#devtools::install_github("FCrSTATS/SBpitch")
library(SBpitch)
library(ggplot2)

p = create_Pitch("#ffffff", "#A9A9A9", "#ffffff", "#000000", BasicFeatures = FALSE, goaltype = "box")

p + geom_point(data = shots, aes(x = location.x, y = location.y), alpha = 0.2, size = 2.5, shape = 16) + theme_void() + labs(title = "Shot Location in NWSL 2018 Season")
```


```{r}
# cleaning the data to remove any columns with only NA values
not_all_na = function(x) any(!is.na(x))
```

```{r}
shots_valid_new <- shots %>%
  select_if(not_all_na)
```

```{r}
# Creating location variables
shots_valid_new <- shots_valid_new %>% mutate(opposite = 120 - location.x,
adjacent = 40 - location.y, hypotenuse = sqrt(opposite^2 + adjacent^2),
angle.to.goal = ifelse(location.y > 40, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14), distance.to.goal = hypotenuse) %>%
select(-c(opposite, adjacent, hypotenuse))
```


```{r}
#adding distance from goalkeeper and angle to gk
shots_valid_new <- shots_valid_new %>% mutate(opposite = location.x.GK - location.x,
                                                adjacent = location.y.GK - location.y,
                                                hypotenuse = sqrt(opposite^2 + adjacent^2),
                                                angle.to.gk = ifelse(location.y > location.y.GK, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14),
                                                angle.to.gk = ifelse(location.x > location.x.GK & location.y < location.y.GK, 270 - asin(opposite/hypotenuse)*180/3.14, angle.to.gk),
                                                distance.to.gk = hypotenuse,
                                                gk.to.goalline = sqrt((120 - location.x.GK)^2 + (40 - location.y.GK)^2)) %>%
                                                  select(-c(opposite, adjacent, hypotenuse))
```

```{r}
# there are a lot of columns with NA that are logical boolean values so replace with FALSE

logical.vars = names(Filter(is.logical, shots_valid_new))

df <- shots_valid_new[logical.vars]
df[is.na(df)] = FALSE
shots_valid_new[logical.vars] = df

```


Building the model:

Information the caret package and how to use it in R for random forests
https://rpubs.com/jkylearmstrong/RandomForest_w_caret

- mtry is the number of randomly selected predictors in the model 

```{r}
# choose independent variables
ind.vars = c("id", "is.goal", 'distance.to.gk', 'DistToGoal', 'angle.to.gk', 'AngleToGoal', 'gk.to.goalline', 'play_pattern.name','shot.body_part.name', 'shot.type.name', 'shot.technique.name')
```

```{r}
library(caret) 

shots.varsdata = subset(shots_valid_new, select = ind.vars) %>%
  drop_na() %>%
  filter(play_pattern.name != "Other")


#splitting into test train
idx = createDataPartition(shots.varsdata$is.goal, p = 0.8, list = F)
train = shots.varsdata[idx,]
test = shots.varsdata[-idx,]
```

```{r}
training_xg <- shots.varsdata$shot.statsbomb_xg[idx]

training_xg

test_xg <- subset(shots_valid_new, select = c(ind.vars, 'shot.statsbomb_xg')) %>%
  drop_na()
```


```{r}
# random forest ml model 
# with metric being Accuracy 
vars <-  ncol(model.matrix(is.goal ~ ., train[,!colnames(train) %in% c("id")])) - 2

grid <-  expand.grid(mtry = 4:vars)

# five folds with cross validation 
control <- trainControl(classProbs = TRUE, method = "cv", number = 5,
                       allowParallel = T, summaryFunction = prSummary, savePredictions = T)

rf.1 <- train(is.goal ~ .,
                    data = train[,!colnames(train) %in% c("id")], 
                    method = "rf",
                    metric = "Accuracy", # looking at highest accuracy for metric
                    trControl = control,
                    tuneGrid = grid,
                    preProcess = c("center", "scale"))

print(rf.1)

```

```{r}
# predictions for test set
xG_test.rf.v1 <- predict(rf.1, test, type = "prob")
```

```{r}
# adding probability of xG to dataset using the random forest model1 
shots.varsdata$my.xG <- predict(rf.1, newdata = shots.varsdata, type = "prob")
```

```{r}
# confusion matrix
confusionMatrix(rf.1)
```
- We see that the average accuracy with this model is 0.9156

```{r}
# Plot 
plot(rf.1)
```
- We see from the plot that the highest AUC scores (takes into account precision and recall) is with 4 randomly selected predictors. 

```{r}
# see how many mtry the model uses
rf.1$bestTune$mtry
```
- The selected model uses 4 randomly selected predictors for the highest accuracy

```{r}
# feature importance 
varImp(rf.1)
```
- With random forests, we can see feature importance. This plot shows 20 most important variables shown. We see that the feature DistToGoal (100%) is important, distance.to.gk (96%), angle.to.gk (83%)


```{r}
shots_valid_NEW <- left_join(shots_valid_new, shots.varsdata[,c("id", "my.xG")], by = 
                               "id")
```

```{r}
# comparing xG and statBombxG
comparison_xg <- shots_valid_NEW %>%
  select(id, my.xG, shot.statsbomb_xg)

comparison_xg
```

```{r}
# shot map showing my model's xG
a1 = p + geom_tile(data = shots_valid_NEW, aes(x = location.x, y = location.y, fill = my.xG$Goal)) + scale_fill_gradient(low = "blue", high = "red") + labs(fill = "xG", title = "Expected Goals Model NWSL 2018 Season")

a1
```


```{r}
# shot map with goals and xG size of point
a2 = p + geom_point(data = shots_valid_NEW, aes(x = location.x, y = location.y, size = my.xG$Goal, color = shot.outcome.name == "Goal")) + labs(size = "xG", color = "Goal?")

a2
```

https://biscuitchaserfc.blogspot.com/2020/05/shot-maps-in-r-using-statsbomb-data.html
- To create shot maps based on xG in the NWSL 2018 season
- I realized that this is not the complete NWSL season -> moving to WWC 2023 match data

```{r}
# player shots
player_shots <- shots_valid_new %>%
  group_by(player.name) %>%
  tally(name = "total_shots")
```

```{r}
# player goals
player_goals <- shots_valid_new %>%
  filter(is.goal == "Goal") %>%
  group_by(player.name) %>%
  tally(name = "Goals")
```

