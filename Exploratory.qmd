---
title: "Data Exploration"
author: "Hope Donoghue"
format: html
---

```{r}
library(readr)
goalscorers <- read_csv("archive/goalscorers.csv")
results <- read_csv("archive/results.csv")
shootouts <- read_csv("archive/shootouts.csv")
```

```{r}
devtools::install_github("statsbomb/StatsBombR")
```

Using event data to create an expected goals model with machine learning techniques for NWSL women's soccer

Inspiration a blog for expected goals model: https://www.gopalakrishnan.me/2019/04/17/xg/

https://statsbomb.com/soccer-metrics/expected-goals-xg-explained/ 

- Goals talk about the results of the shots taken in a game as expected goals talk about the quality of the shots taken in the game and it assigns a value (xG) to each shot, which is the probability of that shot resulting in a goal. Higher xG, means higher chance of a shot becoming a goal. 

- An xG model uses historical information from thousands of shots with similar characteristics to estimate the likelihood of a goal on a scale between 0 and 1.
For example, a shot with an xG value of 0.2 is one that we would generally expect to be converted twice in every 10 attempts.

How is xG calculated?
- Each xG model has its own characteristics, but the main factors are distance to goal, angle to goal, body part with which the shot was taken an take of assist or previous action. 

What have xG models taught us?
- Central shots are best (shots from the central part of the penalty area are more valuable than those from tighter areas)
- Feet over head: from the same distance, foot shots are more likely to result in goals than headed shots. 
- Crosses are more difficult to convert than ground passes


```{r}
library(dbplyr) # database access
library(DBI) # database access
library(tidyverse) # dataframe manipulation
library(tidymodels) # data processing and modeling

#source("../data/pitch_plots.r") # helper function to plot the pitch
```

```{r}
library(StatsBombR)
Comp = FreeCompetitions()
Matches = FreeMatches(Comp)

#Getting data only for the nwsl league
womens_matches_nwsl <- Matches %>%
  filter(home_team.home_team_gender == "female") %>%
  filter(competition.competition_name == "NWSL")
  
# see the first match of data only 
first_match <- get.matchFree(womens_matches_nwsl[1,])

error_game = nrow(Matches) - 39
all_events = data.frame()
for(i in 1:nrow(womens_matches_nwsl)){
  #if(i %in% c(error_game)) next
  temp = get.matchFree(womens_matches_nwsl[i,])
  print(i)
  temp = allclean(temp)
  all_events = bind_rows(all_events, temp)
  rm(temp)
}
```

```{r}
shots <- all_events %>%
  filter(type.name == "Shot")
```

```{r}
shots_valid <- shots %>% mutate(opposite = 120 - location.x,
adjacent = 40 - location.y, hypotenuse = sqrt(opposite^2 + adjacent^2),
                                                angle.to.goal = ifelse(location.y > 40, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14),
                                                distance.to.goal = hypotenuse) %>%
                                                  select(-c(opposite, adjacent, hypotenuse))
```


```{r}
#adding distance from goalkeeper and angle to gk
shots_valid <- shots %>% mutate(opposite = location.x.GK - location.x,
                                                adjacent = location.y.GK - location.y,
                                                hypotenuse = sqrt(opposite^2 + adjacent^2),
                                                angle.to.gk = ifelse(location.y > location.y.GK, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14),
                                                angle.to.gk = ifelse(location.x > location.x.GK & location.y < location.y.GK, 270 - asin(opposite/hypotenuse)*180/3.14, angle.to.gk),
                                                distance.to.gk = hypotenuse,
                                                gk.to.goalline = sqrt((120 - location.x.GK)^2 + (40 - location.y.GK)^2)) %>%
                                                  select(-c(opposite, adjacent, hypotenuse))
```

Building the model:

Information the caret package and how to use it in R for random forests
https://rpubs.com/jkylearmstrong/RandomForest_w_caret

- mtry is the number of randomly selected predictors in the model 

```{r}
library(caret)

shots_valid <- shots_valid %>%
  mutate(is.goal = if_else(shot.outcome.name == "Goal", "Yes", "No"))

#choosing independent variables
shots.varsdata <- shots_valid %>%
  select('id', 'is.goal','distance.to.gk', 'DistToGoal', 'angle.to.gk', 'AngleToGoal', 'gk.to.goalline', 'play_pattern.name','shot.body_part.name', 'shot.type.name', 'shot.technique.name') %>%
  drop_na()

#splitting into test train
idx = createDataPartition(shots.varsdata$is.goal, p = 0.8, list = F)
train = shots.varsdata[idx,]
test = shots.varsdata[-idx,]
```

```{r}
# random forest ml model 
# with metric being Accuracy 
vars = ncol(model.matrix(is.goal ~ ., train[,!colnames(train) %in% c("id")])) - 2
grid = expand.grid(mtry = 4:vars)

# five folds with cross validation 
control = trainControl(classProbs = TRUE, method = "cv", number = 5,
                       allowParallel = T, summaryFunction = prSummary, savePredictions = T)

rf.1 = train(is.goal ~ .,
                    data = train[,!colnames(train) %in% c("id")], 
                    method = "rf",
                    metric = "Accuracy", # looking at highest accuracy for metric
                    trControl = control,
                    tuneGrid = grid,
                    preProcess = c("center", "scale"))

print(rf.1)

```

```{r}
# predictions for test set
xG_test.rf.v1 <- predict(rf.1, test, type = "prob")
```

```{r}
# adding probability of xG to dataset using the random forest model1 
shots.varsdata$my.xG <- predict(rf.1, newdata = shots.varsdata, type = "prob")
```

```{r}
# confusion matrix
confusionMatrix(rf.1)
```
- We see that the average accuracy with this model is 0.9059

```{r}
# Plot 
plot(rf.1)
```
- We see from the plot that the highest AUC scores (takes into account precision and recall) is with 5 randomly selected predictors. 

```{r}
# see how many mtry the model uses
rf.1$bestTune$mtry
```

```{r}
# feature importance 
varImp(rf.1)
```
- With random forests, we can see feature importance. This plot shows 20 most important variables shown. We see that the feature, distance.to.gk is 96%, angle.to.gk is 80%, AngleToGoal is 77%, gk.to.goaline is 74%. 



https://biscuitchaserfc.blogspot.com/2020/05/shot-maps-in-r-using-statsbomb-data.html
- To create shot maps in R for each match in the NWSL season -> TO DO after class:
