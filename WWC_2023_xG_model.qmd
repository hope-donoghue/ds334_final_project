---
title: "WWC 2023 xG"
author: "Hope Donoghue"
format: html
---

```{r}
library(tidyverse)
library(StatsBombR)
Comp = FreeCompetitions()
Matches = FreeMatches(Comp)

#Getting data only for the Women's world cup 2023
wwc_2023 <- Matches %>%
  filter(competition.competition_name == "Women's World Cup") %>%
  filter(season.season_name == "2023")

all_events_wwc2023 <- data.frame()
for(i in 1:nrow(wwc_2023)){
  #if(i %in% c(error_game)) next
  temp = get.matchFree(wwc_2023[i,])
  print(i)
  temp = allclean(temp)
  all_events_wwc2023 = bind_rows(all_events_wwc2023, temp)
  rm(temp)
}
```


```{r}
# only having shots and specifying whether the shot was a goal or not
shots <- all_events_wwc2023 %>%
  filter(type.name == "Shot") %>%
  mutate(is.goal = ifelse(shot.outcome.name == "Goal", "Goal", "NoGoal"))
```


```{r}
# Plotting all the shots in the WWC 2023
library(tidyr)
#devtools::install_github("FCrSTATS/SBpitch")
library(SBpitch)
library(ggplot2)

pitch = create_Pitch("#ffffff", "#A9A9A9", "#ffffff", "#000000", BasicFeatures = FALSE, goaltype = "box")

pitch + geom_point(data = shots, aes(x = location.x, y = location.y), alpha = 0.2, size = 2.5, shape = 16) + theme_void() + labs(title = "Shot Location in Women's World Cup 2023")
```

```{r}
# add sections to the field to differentiate where the shots were taken and which areas
pitch_2 = create_Pitch("#ffffff", "#A9A9A9", "#ffffff", "#000000", BasicFeatures = FALSE, goaltype = "box", JdeP = TRUE)

pitch_2 + geom_point(data = shots, aes(x = location.x, y = location.y), alpha = 0.2, size = 2.5, shape = 16) + theme_void() + labs(title = "Shot Location in Women's World Cup 2023")
```


```{r}
# cleaning the data to remove any columns with only NA values
not_all_na = function(x) any(!is.na(x))
```

```{r}
shots_valid_wwc2023 <- shots %>%
  select_if(not_all_na)
```

```{r}
# Creating location variables
shots_valid_wwc2023 <- shots_valid_wwc2023 %>% 
  mutate(opposite = 120 - location.x,
adjacent = 40 - location.y, hypotenuse = sqrt(opposite^2 + adjacent^2),
angle.to.goal = ifelse(location.y > 40, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14), distance.to.goal = hypotenuse) %>%
select(-c(opposite, adjacent, hypotenuse))
```


```{r}
#adding distance from goalkeeper and angle to gk
shots_valid_wwc2023 <- shots_valid_wwc2023 %>% mutate(opposite = location.x.GK - location.x,
                                                adjacent = location.y.GK - location.y,
                                                hypotenuse = sqrt(opposite^2 + adjacent^2),
                                                angle.to.gk = ifelse(location.y > location.y.GK, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14),
                                                angle.to.gk = ifelse(location.x > location.x.GK & location.y < location.y.GK, 270 - asin(opposite/hypotenuse)*180/3.14, angle.to.gk),
                                                distance.to.gk = hypotenuse,
                                                gk.to.goalline = sqrt((120 - location.x.GK)^2 + (40 - location.y.GK)^2)) %>%
                                                  select(-c(opposite, adjacent, hypotenuse))
```

```{r}
# there are a lot of columns with NA that are logical boolean values so replace with FALSE

logical.vars = names(Filter(is.logical, shots_valid_wwc2023))

df <- shots_valid_wwc2023[logical.vars]
df[is.na(df)] = FALSE
shots_valid_wwc2023[logical.vars] = df

```


```{r}
# choose independent variables
ind.vars = c("id", "is.goal", 'distance.to.gk', 'DistToGoal', 'angle.to.gk', 'angle.to.goal', 'gk.to.goalline', 'play_pattern.name','shot.body_part.name', 'shot.type.name', 'shot.technique.name')
```

```{r}
library(caret) 

shots.varsdata = subset(shots_valid_wwc2023, select = ind.vars) %>%
  drop_na() %>%
  filter(play_pattern.name != "Other")


#splitting into test train
idx = createDataPartition(shots.varsdata$is.goal, p = 0.8, list = F)
train = shots.varsdata[idx,]
test = shots.varsdata[-idx,]
```

```{r}
training_xg <- shots.varsdata$shot.statsbomb_xg[idx]

training_xg

test_xg <- subset(shots_valid_wwc2023, select = c(ind.vars, 'shot.statsbomb_xg')) %>%
  drop_na()
```


```{r}
# random forest ml model 
# with metric being Accuracy 
vars <-  ncol(model.matrix(is.goal ~ ., train[,!colnames(train) %in% c("id")])) - 2

grid <-  expand.grid(mtry = 4:vars)

# five folds with cross validation 
control <- trainControl(classProbs = TRUE, method = "cv", number = 5,
                       allowParallel = T, summaryFunction = prSummary, savePredictions = T)

rf.1 <- train(is.goal ~ .,
                    data = train[,!colnames(train) %in% c("id")], 
                    method = "rf",
                    metric = "Accuracy", # looking at highest accuracy for metric
                    trControl = control,
                    tuneGrid = grid,
                    preProcess = c("center", "scale"))

print(rf.1)

```

```{r}
# predictions for test set
xG_test.rf.1 <- predict(rf.1, test, type = "prob")
```

```{r}
# adding probability of xG to dataset using the random forest model1 
shots.varsdata$my.xG <- predict(rf.1, newdata = shots.varsdata, type = "prob")
```

```{r}
# confusion matrix
confusionMatrix(rf.1)
```
- We see that the accuracy is 92.21%

```{r}
# Plot 
plot(rf.1)
```

```{r}
# see how many mtry the model uses
rf.1$bestTune$mtry
```
- The selected model uses 19 randomly selected predictors for the highest accuracy

```{r}
# feature importance 
varImp(rf.1)
```
We see that DistToGoal and distance.to.gk are important features in the model

```{r}
shots_valid_wwc2023 <- left_join(shots_valid_wwc2023, shots.varsdata[,c("id", "my.xG")], by = 
                               "id")
```


```{r}
# shot map showing my model's xG for the 2023 WWC with Ireland's goal from corner
a3 = pitch + geom_point(data = shots_valid_wwc2023, aes(x = location.x, y = location.y, color = my.xG$Goal)) + labs(color = "xG", title = "Expected Goals Model Women's World Cup 2023")

a3
```

```{r}
# shot map with goals and xG size of point with Ireland's goal from corner
a4 = pitch + geom_point(data = shots_valid_wwc2023, aes(x = location.x, y = location.y, size = my.xG$Goal, color = shot.outcome.name == "Goal")) + labs(size = "xG", color = "Goal")

a4
```

```{r}
# Republic of Ireland's goal from corner kick, which has a very high xG - need to investigate this
goals <- shots_valid_wwc2023 %>%
  filter(shot.outcome.name == "Goal") %>%
  filter(team.name == "Republic of Ireland Women's")
```

```{r}
ireland_goal_corner <- shots_valid_wwc2023 %>%
  filter(id == "98386656-d17e-408a-95b1-57422c5aa0e3")
```
- We see that the xG model is 0.714 for that goal, but scoring from a corner is a really rare goal.

Model 2: (not as effective as model 1)

```{r}
# choose independent variables
ind.vars = c("id", "is.goal", 'distance.to.gk', 'DistToGoal', 'angle.to.gk', 'angle.to.goal', 'gk.to.goalline', 'play_pattern.name','shot.body_part.name', 'shot.type.name', 'shot.technique.name', 'shot.open_goal', 'shot.deflected', 'shot.redirect', 'DefendersBehindBall', 'AttackersBehindBall', 'avevelocity', 'shot.one_on_one', 'shot.first_time')
```

```{r}
library(caret) 

shots.varsdata = subset(shots_valid_wwc2023, select = ind.vars) %>%
  drop_na() %>%
  filter(play_pattern.name != "Other")


#splitting into test train
idx = createDataPartition(shots.varsdata$is.goal, p = 0.8, list = F)
train = shots.varsdata[idx,]
test = shots.varsdata[-idx,]
```

```{r}
training_xg <- shots.varsdata$shot.statsbomb_xg[idx]

training_xg

test_xg <- subset(shots_valid_wwc2023, select = c(ind.vars, 'shot.statsbomb_xg')) %>%
  drop_na()
```


```{r}
# random forest ml model 
# with metric being Accuracy 
vars <-  ncol(model.matrix(is.goal ~ ., train[,!colnames(train) %in% c("id")])) - 2

grid <-  expand.grid(mtry = 4:vars)

# five folds with cross validation 
control <- trainControl(classProbs = TRUE, method = "cv", number = 5,
                       allowParallel = T, summaryFunction = prSummary, savePredictions = T)

rf.2 <- train(is.goal ~ .,
                    data = train[,!colnames(train) %in% c("id")], 
                    method = "rf",
                    metric = "Accuracy", # looking at highest accuracy for metric
                    trControl = control,
                    tuneGrid = grid,
                    preProcess = c("center", "scale"))

print(rf.2)

```

```{r}
# predictions for test set
xG_test.rf.2 <- predict(rf.2, test, type = "prob")
```

```{r}
# adding probability of xG to dataset using the random forest model1 
shots.varsdata$my.xG <- predict(rf.2, newdata = shots.varsdata, type = "prob")
```

```{r}
# confusion matrix
confusionMatrix(rf.2)
```
- We see that the accuracy is 0.9158

```{r}
# Plot 
plot(rf.2)
```

```{r}
# see how many mtry the model uses
rf.2$bestTune$mtry
```
- The selected model uses 11 randomly selected predictors for the highest accuracy

```{r}
# feature importance 
varImp(rf.2)
```
- We see in the second model that DistToGoal is important along with distance.to.gk



 ****I decided to fit the model without the Ireland corner goal to see what happens:****

```{r}
shots_valid_wwc2023_no_corner <- shots %>%
  filter(id != "98386656-d17e-408a-95b1-57422c5aa0e3") %>%
  select_if(not_all_na)
```

```{r}
# Creating location variables
shots_valid_wwc2023_no_corner <- shots_valid_wwc2023_no_corner %>% 
  mutate(opposite = 120 - location.x,
adjacent = 40 - location.y, hypotenuse = sqrt(opposite^2 + adjacent^2),
angle.to.goal = ifelse(location.y > 40, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14), distance.to.goal = hypotenuse) %>%
select(-c(opposite, adjacent, hypotenuse))
```


```{r}
#adding distance from goalkeeper and angle to gk
shots_valid_wwc2023_no_corner <- shots_valid_wwc2023_no_corner %>% mutate(opposite = location.x.GK - location.x,
                                                adjacent = location.y.GK - location.y,
                                                hypotenuse = sqrt(opposite^2 + adjacent^2),
                                                angle.to.gk = ifelse(location.y > location.y.GK, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14),
                                                angle.to.gk = ifelse(location.x > location.x.GK & location.y < location.y.GK, 270 - asin(opposite/hypotenuse)*180/3.14, angle.to.gk),
                                                distance.to.gk = hypotenuse,
                                                gk.to.goalline = sqrt((120 - location.x.GK)^2 + (40 - location.y.GK)^2)) %>%
                                                  select(-c(opposite, adjacent, hypotenuse))
```

```{r}
# there are a lot of columns with NA that are logical boolean values so replace with FALSE

logical.vars = names(Filter(is.logical, shots_valid_wwc2023_no_corner))

df <- shots_valid_wwc2023_no_corner[logical.vars]
df[is.na(df)] = FALSE
shots_valid_wwc2023_no_corner[logical.vars] = df

```


```{r}
# choose independent variables
ind.vars = c("id", "is.goal", 'distance.to.gk', 'DistToGoal', 'angle.to.gk', 'angle.to.goal', 'gk.to.goalline', 'play_pattern.name','shot.body_part.name', 'shot.type.name', 'shot.technique.name')
```

```{r}
library(caret) 
library(tidyverse)

shots.varsdata = subset(shots_valid_wwc2023_no_corner, select = ind.vars) %>%
  drop_na() %>%
  filter(play_pattern.name != "Other")


#splitting into test train
idx = createDataPartition(shots.varsdata$is.goal, p = 0.8, list = F)
train = shots.varsdata[idx,]
test = shots.varsdata[-idx,]
```

```{r}
training_xg <- shots.varsdata$shot.statsbomb_xg[idx]

training_xg

test_xg <- subset(shots_valid_wwc2023_no_corner, select = c(ind.vars, 'shot.statsbomb_xg')) %>%
  drop_na()
```


```{r}
# random forest ml model 
# with metric being Accuracy 
vars <-  ncol(model.matrix(is.goal ~ ., train[,!colnames(train) %in% c("id")])) - 2

grid <-  expand.grid(mtry = 4:vars)

# five folds with cross validation 
control <- trainControl(classProbs = TRUE, method = "cv", number = 5,
                       allowParallel = T, summaryFunction = prSummary, savePredictions = T)

rf.1_no_corner <- train(is.goal ~ .,
                    data = train[,!colnames(train) %in% c("id")], 
                    method = "rf",
                    metric = "Accuracy", # looking at highest accuracy for metric
                    trControl = control,
                    tuneGrid = grid,
                    preProcess = c("center", "scale"))

print(rf.1_no_corner)

```

```{r}
# predictions for test set
xG_test.rf.1_no_corner <- predict(rf.1_no_corner, test, type = "prob")
```

```{r}
# adding probability of xG to dataset using the random forest model1 
shots.varsdata$my.xG <- predict(rf.1_no_corner, newdata = shots.varsdata, type = "prob")
```

```{r}
# confusion matrix
confusionMatrix(rf.1_no_corner)
```
- We see that the accuracy is 92.12%

```{r}
# Plot 
plot(rf.1_no_corner)
```

```{r}
# see how many mtry the model uses
rf.1_no_corner$bestTune$mtry
```
- The selected model uses 7 randomly selected predictors for the highest accuracy

```{r}
# feature importance 
varImp(rf.1_no_corner)
```
We see that DistToGoal and distance.to.gk are important features in the model (100% and 92.15% respectively)

```{r}
shots_valid_wwc2023_no_corner <- left_join(shots_valid_wwc2023_no_corner, shots.varsdata[,c("id", "my.xG")], by = "id")
```

```{r}
# shot map showing my model's xG for the 2023 WWC without Republic of Ireland's goal from corner
a3 = pitch + geom_point(data = shots_valid_wwc2023_no_corner, aes(x = location.x, y = location.y, color = my.xG$Goal)) + labs(color = "xG", title = "Expected Goals Model Women's World Cup 2023")

a3
```

```{r}
# shot map with goals without Republic Ireland's goal from corner
a4 = pitch_2 + geom_point(data = shots_valid_wwc2023_no_corner, aes(x = location.x, y = location.y, size = my.xG$Goal)) + labs(size = "xG", caption = "Removed Republic of Ireland's goal directly from corner", title = "Expected Goals Model Women's World Cup 2023")

a4
```

```{r}
# adding stroke to the points to add border
# figure out how to add shot result
a5 = pitch + geom_point(data = shots_valid_wwc2023_no_corner, aes(x = location.x, y = location.y, size = my.xG$Goal, stroke = 0.5, alpha = 0.2, color = is.goal)) + labs(size = "xG", caption = "Removed Republic of Ireland's goal directly from corner", title = "Expected Goals Model Women's World Cup 2023")

a5
```

```{r}
# shot map with goals without Republic Ireland's goal from corner
a6 = pitch + geom_point(data = shots_valid_wwc2023_no_corner, aes(x = location.x, y = location.y, size = my.xG$Goal)) + labs(size = "xG", caption = "Removed Republic of Ireland's goal directly from corner", title = "Expected Goals Model Women's World Cup 2023")

a6
```

```{r}
# using open point shape to include stroke and color to the shot map
# stroke argument needs numeric variables

shots_valid_wwc2023_no_corner <- shots_valid_wwc2023_no_corner %>%
  mutate(is.goal_numeric = if_else(is.goal == "Goal", 1.5, 0.5))

a7 = pitch + geom_point(data = shots_valid_wwc2023_no_corner, aes(x = location.x, y = location.y, color = my.xG$Goal, stroke = is.goal_numeric), shape = 1, size = 2) + labs(color = "xG", caption = "Removed Republic of Ireland's goal directly from corner; Darker circles mean goal was scored", title = "Expected Goals Model WWC 2023")

a7
```

```{r}
a7 = pitch + geom_point(data = shots_valid_wwc2023_no_corner, 
                        aes(x = location.x, y = location.y, color = my.xG$Goal, 
                        linetype = is.goal), 
                        shape = 1)

a7
```




Individual players:

```{r}
library(dplyr)
# player shots
player_shots <- shots_valid_wwc2023_no_corner %>%
  group_by(player.name) %>%
  tally(name = "total_shots")
```

```{r}
# player goals
player_goals <- shots_valid_wwc2023_no_corner %>%
  filter(is.goal == "Goal") %>%
  group_by(player.name) %>%
  tally(name = "Goals", sort = TRUE)
```

```{r}
# Top 15
player_xg <- shots_valid_wwc2023_no_corner %>%
  group_by(player.name) %>%
  tally(my.xG$Goal, name = "total_xg", sort = TRUE) %>%
  top_n(15)
```

```{r}
summary_data <- left_join(player_xg, player_shots, by = "player.name") %>%
  mutate(xg_per_shot = sprintf("%0.2f", total_xg/total_shots))

summary_data <- left_join(summary_data, player_goals, by = "player.name")
```


```{r, warning = FALSE, message = FALSE}
library(ggsoccer)
players_data <- shots_valid_wwc2023_no_corner %>%
  filter(player.name %in% c("Amanda Ilestedt",
                            "Jill Roord",
                            "Hinata Miyazawa",
                            "Jennifer Hermoso Fuentes",
                            "Alba María Redondo Ferrer",
                            "Eugénie Le Sommer",
                            "Thembi Kgatlana",
                            "Aitana Bonmati Conca",
                            "Alexandra Popp",
                            "Alessia Russo",
                            "Lauren James",
                            "Lauren Hemp",
                            "Rebecka Blomqvist",
                            "Kadidiatou Diani",
                            "Sophie Roman Haug"))

 ggplot() + annotate_pitch(dimensions = pitch_statsbomb) + theme_pitch() + coord_flip(xlim = c(55, 120), ylim = c(-12, 105)) + geom_point(data = players_data, aes(x = location.x, y = location.y, size = my.xG$Goal, color = shot.outcome.name == "Goal")) + facet_wrap(~player.name) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 65, y = 15, label = paste0("xG Total: ", round(total_xg), digits = 2))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 55, y = 15, label = paste0("xG Per Shot: ", xg_per_shot))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 65, y = 65, label = paste0("Goals: ", Goals))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 55, y = 65, label = paste0("Total Shots: ", total_shots))) + labs(title = "Top 10 Players Total xG WWC 2023", color = "Goal", size = "xG")
```

```{r, warning = FALSE, message = FALSE}
# using stroke now and thicker border on the points means goal was scored
library(dplyr)
library(ggplot2)
library(ggsoccer)
players_data <- shots_valid_wwc2023_no_corner %>%
  filter(player.name %in% c("Amanda Ilestedt",
                            "Jill Roord",
                            "Hinata Miyazawa",
                            "Jennifer Hermoso Fuentes",
                            "Alba María Redondo Ferrer",
                            "Eugénie Le Sommer",
                            "Thembi Kgatlana",
                            "Aitana Bonmati Conca",
                            "Alexandra Popp",
                            "Alessia Russo",
                            "Lauren James",
                            "Lauren Hemp",
                            "Rebecka Blomqvist",
                            "Kadidiatou Diani",
                            "Sophie Roman Haug"))

 ggplot() + annotate_pitch(dimensions = pitch_statsbomb) + theme_pitch() + coord_flip(xlim = c(55, 120), ylim = c(-12, 105)) + geom_point(data = players_data, aes(x = location.x, y = location.y, color = my.xG$Goal, stroke = is.goal_numeric), shape = 1, size = 1.5) + facet_wrap(~player.name) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 65, y = 15, label = paste0("xG Total: ", round(total_xg), digits = 2))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 55, y = 15, label = paste0("xG Per Shot: ", xg_per_shot))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 65, y = 65, label = paste0("Goals: ", Goals))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 55, y = 65, label = paste0("Total Shots: ", total_shots))) + labs(title = "Top 15 Players Total xG WWC 2023", stroke = "Goal", color = "xG")

```
 
Suggestions: Use Plotly to click on point and see which game the shot was from:
Figure out what opposition team based on goalkeeper and add that to dataset

```{r}
library(dplyr)
shots_valid_opponent <- shots_valid_wwc2023_no_corner %>%
  select(id, match_id, possession_team.name, team.name, player.name.GK ) %>%
  mutate(opponent = case_when(player.name.GK == "Mackenzie Arnold" ~ "Australia", player.name.GK == "Mary Alexandra Earps" ~ "England", player.name.GK == "Catalina Thomas Coll Lluch" ~ "Spain", player.name.GK == "Zecira Musovic" ~ "Sweden", player.name.GK == "Eunice Sakala" ~ "Zambia", player.name.GK == "María Isabel Rodríguez Rivero" ~ "Spain", player.name.GK == "Yenith Elizabett Bailey de la Cruz" ~ "Panama", player.name.GK == "Letícia Izidoro Lima da Silva" ~ "Brazil", player.name.GK == "Inês Teixeira Pereira" ~ "Portugal", player.name.GK == "Daphne van Domselaar" ~ "Netherlands", player.name.GK == "Ayaka Yamashita" ~ "Japan", player.name.GK == "Francesca Durante" ~ "Italy", player.name.GK == "Chiamaka Cynthia Nnadozie" ~ "Nigeria", player.name.GK == "Kailen Mary Iacovoni Sheridan" ~ "Canada", player.name.GK == "Catalina Pérez Jaramillo" ~ "Colombia", player.name.GK == "Rebecca Leigh Spencer" ~ "Jamaica", player.name.GK == "Pauline Peyraud Magnin" ~ "France", player.name.GK == "Solène Durand" ~ "France", player.name.GK == "Alyssa Michele Naeher" ~ "United States", player.name.GK == "Kaylin Swart" ~ "South Africa", player.name.GK == "Khadija Er-Rmichi" ~ "Morocco", player.name.GK == "Lene Christensen" ~ "Denmark", player.name.GK == "Aurora Watten Mikalsen" ~ "Norway", player.name.GK == "Gaëlle Thalmann" ~ "Switzerland", player.name.GK == "Daniela Solera Vega" ~ "Costa Rica", player.name.GK == "Catherine Musonda" ~ "Zambia", player.name.GK == "Vanina Noemí Correa" ~ "Argentina", player.name.GK == "Kerly Théus" ~ "Haiti", player.name.GK == "Yu Zhu" ~ "China PR", player.name.GK == "Patricia Isabel Sousa Barros Morais" ~ "Portugal", player.name.GK == "Kim Thanh Trần Thị" ~ "Vietnam", player.name.GK == "Courtney Brosnan" ~ "Republic of Ireland", player.name.GK == "Olivia Alexandra Davies Isip McDaniel" ~ "Philippines", player.name.GK == "Victoria Esson" ~ "New Zealand", player.name.GK == "Jung-Mi Kim" ~ "Korea Republic", player.name.GK == "Merle Frohms" ~ "Germany", player.name.GK == "Jennifer Miley Falk" ~ "Sweden", player.name.GK == "Thị Hằng Khổng" ~ "Vietnam", player.name.GK == "Young-Geul Yoon" ~ "Korea Republic", player.name.GK == "Huan Xu" ~ "China PR"))
  
```

```{r}
# replace NA goalkeeper
shots_valid_opponent$opponent[40] <- "England"
shots_valid_opponent$opponent[54] <- "Australia"
shots_valid_opponent$opponent[238] <- "Nigeria"
shots_valid_opponent$opponent[307] <- "Australia"
shots_valid_opponent$opponent[308] <- "France"
shots_valid_opponent$opponent[309] <- "Australia"
shots_valid_opponent$opponent[310] <- "France"
shots_valid_opponent$opponent[311] <- "Australia"
shots_valid_opponent$opponent[312] <- "France"
shots_valid_opponent$opponent[313] <- "Australia"
shots_valid_opponent$opponent[314] <- "France"
shots_valid_opponent$opponent[315] <- "Australia"
shots_valid_opponent$opponent[317] <- "Australia"
shots_valid_opponent$opponent[318] <- "France"
shots_valid_opponent$opponent[319] <- "Australia"
shots_valid_opponent$opponent[320] <- "France"
shots_valid_opponent$opponent[321] <- "Australia"
shots_valid_opponent$opponent[322] <- "France"
shots_valid_opponent$opponent[323] <- "Australia"
shots_valid_opponent$opponent[324] <- "France"
shots_valid_opponent$opponent[326] <- "France"
shots_valid_opponent$opponent[383] <- "Sweden"
shots_valid_opponent$opponent[384] <- "United States"
shots_valid_opponent$opponent[385] <- "Sweden"
shots_valid_opponent$opponent[386] <- "United States"
shots_valid_opponent$opponent[387] <- "Sweden"
shots_valid_opponent$opponent[390] <- "United States"
shots_valid_opponent$opponent[392] <- "United States"
shots_valid_opponent$opponent[393] <- "Sweden"
shots_valid_opponent$opponent[394] <- "United States"
shots_valid_opponent$opponent[396] <- "United States"
shots_valid_opponent$opponent[438] <- "Netherlands"
shots_valid_opponent$opponent[471] <- "Japan"
shots_valid_opponent$opponent[603] <- "Nigeria"
shots_valid_opponent$opponent[605] <- "Nigeria"
shots_valid_opponent$opponent[606] <- "England"
shots_valid_opponent$opponent[607] <- "Nigeria"
shots_valid_opponent$opponent[608] <- "England"
shots_valid_opponent$opponent[609] <- "Nigeria"
shots_valid_opponent$opponent[667] <- "Costa Rica"
shots_valid_opponent$opponent[747] <- "Haiti"
shots_valid_opponent$opponent[886] <- "Republic of Ireland"
shots_valid_opponent$opponent[932] <- "Philippines"
shots_valid_opponent$opponent[948] <- "Haiti"
shots_valid_opponent$opponent[982] <- "Vietnam"
shots_valid_opponent$opponent[1017] <- "Costa Rica"
shots_valid_opponent$opponent[1080] <- "Colombia"
shots_valid_opponent$opponent[1130] <- "South Africa"
shots_valid_opponent$opponent[1170] <- "Argentina"
shots_valid_opponent$opponent[1189] <- "Panama"
shots_valid_opponent$opponent[1194] <- "Panama"
shots_valid_opponent$opponent[1196] <- "France"
shots_valid_opponent$opponent[1215] <- "England"
shots_valid_opponent$opponent[1276] <- "Haiti"
shots_valid_opponent$opponent[1328] <- "Canada"
shots_valid_opponent$opponent[1345] <- "Philippines"
shots_valid_opponent$opponent[1412] <- "Colombia"
shots_valid_opponent$opponent[1552] <- "Korea Republic"
shots_valid_opponent$opponent[1679] <- "Zambia"


```

```{r}
look_at <- shots_valid_opponent %>%
  filter(match_id == "3893793")
```


```{r}
library(stringr)
shots_valid_opponent$team.name <- str_remove(shots_valid_opponent$team.name, "Women's")
```

```{r}
# join shots_valid_wwc2023_no_corner with shots_valid_opponent to get opponent information added to dataset  

shots_valid_wwc2023_test_1 <- full_join(shots_valid_opponent, shots_valid_wwc2023_no_corner, by = "id")
```


```{r}
player_dataset <- shots_valid_wwc2023_test_1 %>%
    rename("Play_Type" = play_pattern.name) %>%
    rename("Opponent" = opponent) %>%
    rename("xG" = my.xG) 
```



```{r}
# use plotly for specific players, 
# what to do because some of the xG are 0


library(plotly)
library(ggsoccer)

players_data <- player_dataset %>%
  filter(player.name %in% c("Thembi Kgatlana"))

plotly_shot_map <- ggplot(data = players_data, aes(x = location.x, y = location.y, color = xG$Goal, stroke = is.goal_numeric, label = Play_Type, secondlabel = Opponent)) + annotate_pitch(dimensions = pitch_statsbomb) + theme_pitch() + coord_flip(xlim = c(55, 120), ylim = c(-12, 105)) + geom_point(shape = 1, size = 1.5) + labs(title = "Thembi Kgatlana xG Shot Map", color = "xG")


ggplotly(plotly_shot_map, tooltip = c("color", "label", "secondlabel"))
```


```{r}

library(plotly)
library(ggsoccer)

players_data <- player_dataset %>%
  filter(player.name %in% c("Alessia Russo"))

plotly_shot_map <- ggplot(data = players_data, aes(x = location.x, y = location.y, color = xG$Goal, stroke = is.goal_numeric, label = Play_Type, secondlabel = Opponent)) + annotate_pitch(dimensions = pitch_statsbomb) + theme_pitch() + coord_flip(xlim = c(55, 120), ylim = c(-12, 105)) + geom_point(shape = 1, size = 1.5) + labs(title = "Alessia Russo xG Shot Map", color = "xG")


ggplotly(plotly_shot_map, tooltip = c("color", "label", "secondlabel"))
```


```{r}
# pull out levels of players and team
library(tidyverse)
players_unique <- player_dataset %>%
  pull(player.name) %>%
  unique()

team_unique <- player_dataset %>% 
  pull(team.name.x) %>%
  unique()

```

```{r, warning = FALSE, message = FALSE}
# shiny App
library(shiny)

ui <- fluidPage(sidebarLayout(
  sidebarPanel(
    selectInput("team_sel", "Choose a team:", choices = team_unique),
    selectInput("player_sel", "Choose a player:", choices = NULL)),
  
  mainPanel(plotlyOutput("shot_map"))
  )
  
  
)

server <- function(input, output, session) {
  
  observeEvent(input$team_sel, {
    
    player_choices <- player_dataset %>% 
      filter(team.name.x == input$team_sel) %>% 
      distinct(player.name) %>% pull(player.name)
    
    updateSelectInput(inputId = "player_sel", 
                      choices = player_choices)
  })
  
  player_team <- reactive({
    player_team <- player_dataset %>%
      filter(player.name == input$player_sel) %>%
      filter(team.name.x == input$team_sel) 
    
  })
  
  output$shot_map <- renderPlotly({
  plotly_shot_map <- ggplot(data = player_team(), aes(x = location.x, y = location.y, color = xG$Goal, stroke = is.goal_numeric, label = Play_Type, secondlabel = Opponent)) +
   annotate_pitch(dimensions = pitch_statsbomb) + theme_pitch() + coord_flip(xlim = c(55, 120), ylim = c(-12, 105)) + geom_point(shape = 1, size = 1.5) + labs(title = "Shot Map", color = "xG")
    
  ggplotly(plotly_shot_map, tooltip = c("color", "label", "secondlabel"))
  })
  
  
  
}

shinyApp(ui, server)
```


```{r}
# shot technique numbers
shots_valid_wwc2023_test_1 %>%
  group_by(shot.technique.name) %>%
  summarise(n())

# shot type name
shots_valid_wwc2023_test_1 %>%
  group_by(shot.type.name) %>%
  summarise(n())
```



```{r}
# Trying to see how many 0s there are
# Logistic regression 

library(broom)

goal_glm <- glm(as.factor(is.goal) ~ distance.to.gk + DistToGoal + angle.to.gk + angle.to.goal + gk.to.goalline + play_pattern.name + shot.body_part.name + shot.type.name + shot.technique.name, data = shots_valid_wwc2023_test_1, family = "binomial")

goal_glm |> tidy()


```

```{r}
library(modelr)
grid <- shots_valid_wwc2023_test_1 |>
  data_grid(
    distance.to.gk = seq_range(distance.to.gk, n = 5),
    DistToGoal = seq_range(DistToGoal, n = 5),
    angle.to.gk = seq_range(angle.to.gk, n = 5),
    angle.to.goal = seq_range(angle.to.goal, n = 5),
    gk.to.goalline = seq_range(gk.to.goalline, n = 5),
    play_pattern.name = c("From Counter", "From Free Kick", "From Goal Kick", "From Keeper", "From Kick Off", "From Throw In", "Other", "Regular Play"),
    shot.body_part.name = c("Head", "Left Foot", "Other", "Right Foot"),
    shot.type.name = c("Free Kick", "Open Play", "Penalty"),
    shot.technique.name = c("Backheel", "Diving Header", "Half Volley", "Lob", "Normal", "Overhead Kick", "Volley"))
    
grid

augment <-augment(goal_glm, newdata = grid,
                    se_fit = TRUE)

augment

```


```{r}
# Convert .fitted values to predicted probabilities

aug_prob <- augment %>%
  mutate(.fitted = (exp(.fitted)/(1+exp(.fitted))))

aug_prob

```




