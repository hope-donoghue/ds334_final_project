---
title: "WWC 2023 xG"
author: "Hope Donoghue"
format: html
---

```{r}
library(tidyverse)
library(StatsBombR)
Comp = FreeCompetitions()
Matches = FreeMatches(Comp)

#Getting data only for the Women's world cup 2023
wwc_2023 <- Matches %>%
  filter(competition.competition_name == "Women's World Cup") %>%
  filter(season.season_name == "2023")

all_events_wwc2023 <- data.frame()
for(i in 1:nrow(wwc_2023)){
  #if(i %in% c(error_game)) next
  temp = get.matchFree(wwc_2023[i,])
  print(i)
  temp = allclean(temp)
  all_events_wwc2023 = bind_rows(all_events_wwc2023, temp)
  rm(temp)
}
```


```{r}
# only having shots and specifying whether the shot was a goal or not
shots <- all_events_wwc2023 %>%
  filter(type.name == "Shot") %>%
  mutate(is.goal = ifelse(shot.outcome.name == "Goal", "Goal", "NoGoal"))
```


```{r}
# Plotting all the shots in the WWC 2023
library(tidyr)
#devtools::install_github("FCrSTATS/SBpitch")
library(SBpitch)
library(ggplot2)

pitch = create_Pitch("#ffffff", "#A9A9A9", "#ffffff", "#000000", BasicFeatures = FALSE, goaltype = "box")

pitch + geom_point(data = shots, aes(x = location.x, y = location.y), alpha = 0.2, size = 2.5, shape = 16) + theme_void() + labs(title = "Shot Location in Women's World Cup 2023")
```

```{r}
# add sections to the field to differentiate where the shots were taken and which areas
pitch_2 = create_Pitch("#ffffff", "#A9A9A9", "#ffffff", "#000000", BasicFeatures = FALSE, goaltype = "box", JdeP = TRUE)

pitch_2 + geom_point(data = shots, aes(x = location.x, y = location.y), alpha = 0.2, size = 2.5, shape = 16) + theme_void() + labs(title = "Shot Location in Women's World Cup 2023")
```


```{r}
# cleaning the data to remove any columns with only NA values
not_all_na = function(x) any(!is.na(x))
```

```{r}
shots_valid_wwc2023 <- shots %>%
  select_if(not_all_na)
```

```{r}
# Creating location variables
shots_valid_wwc2023 <- shots_valid_wwc2023 %>% 
  mutate(opposite = 120 - location.x,
adjacent = 40 - location.y, hypotenuse = sqrt(opposite^2 + adjacent^2),
angle.to.goal = ifelse(location.y > 40, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14), distance.to.goal = hypotenuse) %>%
select(-c(opposite, adjacent, hypotenuse))
```


```{r}
#adding distance from goalkeeper and angle to gk
shots_valid_wwc2023 <- shots_valid_wwc2023 %>% mutate(opposite = location.x.GK - location.x,
                                                adjacent = location.y.GK - location.y,
                                                hypotenuse = sqrt(opposite^2 + adjacent^2),
                                                angle.to.gk = ifelse(location.y > location.y.GK, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14),
                                                angle.to.gk = ifelse(location.x > location.x.GK & location.y < location.y.GK, 270 - asin(opposite/hypotenuse)*180/3.14, angle.to.gk),
                                                distance.to.gk = hypotenuse,
                                                gk.to.goalline = sqrt((120 - location.x.GK)^2 + (40 - location.y.GK)^2)) %>%
                                                  select(-c(opposite, adjacent, hypotenuse))
```

```{r}
# there are a lot of columns with NA that are logical boolean values so replace with FALSE

logical.vars = names(Filter(is.logical, shots_valid_wwc2023))

df <- shots_valid_wwc2023[logical.vars]
df[is.na(df)] = FALSE
shots_valid_wwc2023[logical.vars] = df

```


```{r}
# choose independent variables
ind.vars = c("id", "is.goal", 'distance.to.gk', 'DistToGoal', 'angle.to.gk', 'angle.to.goal', 'gk.to.goalline', 'play_pattern.name','shot.body_part.name', 'shot.type.name', 'shot.technique.name')
```

```{r}
library(caret) 

shots.varsdata = subset(shots_valid_wwc2023, select = ind.vars) %>%
  drop_na() %>%
  filter(play_pattern.name != "Other")


#splitting into test train
idx = createDataPartition(shots.varsdata$is.goal, p = 0.8, list = F)
train = shots.varsdata[idx,]
test = shots.varsdata[-idx,]
```

```{r}
training_xg <- shots.varsdata$shot.statsbomb_xg[idx]

training_xg

test_xg <- subset(shots_valid_wwc2023, select = c(ind.vars, 'shot.statsbomb_xg')) %>%
  drop_na()
```


```{r}
# random forest ml model 
# with metric being Accuracy 
vars <-  ncol(model.matrix(is.goal ~ ., train[,!colnames(train) %in% c("id")])) - 2

grid <-  expand.grid(mtry = 4:vars)

# five folds with cross validation 
control <- trainControl(classProbs = TRUE, method = "cv", number = 5,
                       allowParallel = T, summaryFunction = prSummary, savePredictions = T)

rf.1 <- train(is.goal ~ .,
                    data = train[,!colnames(train) %in% c("id")], 
                    method = "rf",
                    metric = "Accuracy", # looking at highest accuracy for metric
                    trControl = control,
                    tuneGrid = grid,
                    preProcess = c("center", "scale"))

print(rf.1)

```

```{r}
# predictions for test set
xG_test.rf.1 <- predict(rf.1, test, type = "prob")
```

```{r}
# adding probability of xG to dataset using the random forest model1 
shots.varsdata$my.xG <- predict(rf.1, newdata = shots.varsdata, type = "prob")
```

```{r}
# confusion matrix
confusionMatrix(rf.1)
```
- We see that the accuracy is 91.35%

```{r}
# Plot 
plot(rf.1)
```

```{r}
# see how many mtry the model uses
rf.1$bestTune$mtry
```
- The selected model uses 10 randomly selected predictors for the highest accuracy

```{r}
# feature importance 
varImp(rf.1)
```
We see that DistToGoal and distance.to.gk are important features in the model

```{r}
shots_valid_wwc2023 <- left_join(shots_valid_wwc2023, shots.varsdata[,c("id", "my.xG")], by = 
                               "id")
```


```{r}
# shot map showing my model's xG for the 2023 WWC with Ireland's goal from corner
a3 = pitch + geom_point(data = shots_valid_wwc2023, aes(x = location.x, y = location.y, color = my.xG$Goal)) + labs(color = "xG", title = "Expected Goals Model Women's World Cup 2023")

a3
```

```{r}
# shot map with goals and xG size of point with Ireland's goal from corner
a4 = pitch + geom_point(data = shots_valid_wwc2023, aes(x = location.x, y = location.y, size = my.xG$Goal, color = shot.outcome.name == "Goal")) + labs(size = "xG", color = "Goal")

a4
```

```{r}
# Republic of Ireland's goal from corner kick, which has a very high xG - need to investigate this
goals <- shots_valid_wwc2023 %>%
  filter(shot.outcome.name == "Goal") %>%
  filter(team.name == "Republic of Ireland Women's")
```

```{r}
ireland_goal_corner <- shots_valid_wwc2023 %>%
  filter(id == "98386656-d17e-408a-95b1-57422c5aa0e3")
```
- We see that the xG model is 0.714 for that goal, but scoring from a corner is a really rare goal.

Model 2: (not as effective as model 1)

```{r}
# choose independent variables
ind.vars = c("id", "is.goal", 'distance.to.gk', 'DistToGoal', 'angle.to.gk', 'angle.to.goal', 'gk.to.goalline', 'play_pattern.name','shot.body_part.name', 'shot.type.name', 'shot.technique.name', 'shot.open_goal', 'shot.deflected', 'shot.redirect', 'DefendersBehindBall', 'AttackersBehindBall', 'avevelocity', 'shot.one_on_one', 'shot.first_time')
```

```{r}
library(caret) 

shots.varsdata = subset(shots_valid_wwc2023, select = ind.vars) %>%
  drop_na() %>%
  filter(play_pattern.name != "Other")


#splitting into test train
idx = createDataPartition(shots.varsdata$is.goal, p = 0.8, list = F)
train = shots.varsdata[idx,]
test = shots.varsdata[-idx,]
```

```{r}
training_xg <- shots.varsdata$shot.statsbomb_xg[idx]

training_xg

test_xg <- subset(shots_valid_wwc2023, select = c(ind.vars, 'shot.statsbomb_xg')) %>%
  drop_na()
```


```{r}
# random forest ml model 
# with metric being Accuracy 
vars <-  ncol(model.matrix(is.goal ~ ., train[,!colnames(train) %in% c("id")])) - 2

grid <-  expand.grid(mtry = 4:vars)

# five folds with cross validation 
control <- trainControl(classProbs = TRUE, method = "cv", number = 5,
                       allowParallel = T, summaryFunction = prSummary, savePredictions = T)

rf.2 <- train(is.goal ~ .,
                    data = train[,!colnames(train) %in% c("id")], 
                    method = "rf",
                    metric = "Accuracy", # looking at highest accuracy for metric
                    trControl = control,
                    tuneGrid = grid,
                    preProcess = c("center", "scale"))

print(rf.2)

```

```{r}
# predictions for test set
xG_test.rf.2 <- predict(rf.2, test, type = "prob")
```

```{r}
# adding probability of xG to dataset using the random forest model1 
shots.varsdata$my.xG <- predict(rf.2, newdata = shots.varsdata, type = "prob")
```

```{r}
# confusion matrix
confusionMatrix(rf.2)
```
- We see that the accuracy is 0.9158

```{r}
# Plot 
plot(rf.2)
```

```{r}
# see how many mtry the model uses
rf.2$bestTune$mtry
```
- The selected model uses 11 randomly selected predictors for the highest accuracy

```{r}
# feature importance 
varImp(rf.2)
```
- We see in the second model that DistToGoal is important along with distance.to.gk



 ****I decided to fit the model without the Ireland corner goal to see what happens:****

```{r}
shots_valid_wwc2023_no_corner <- shots %>%
  filter(id != "98386656-d17e-408a-95b1-57422c5aa0e3") %>%
  select_if(not_all_na)
```

```{r}
# Creating location variables
shots_valid_wwc2023_no_corner <- shots_valid_wwc2023_no_corner %>% 
  mutate(opposite = 120 - location.x,
adjacent = 40 - location.y, hypotenuse = sqrt(opposite^2 + adjacent^2),
angle.to.goal = ifelse(location.y > 40, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14), distance.to.goal = hypotenuse) %>%
select(-c(opposite, adjacent, hypotenuse))
```


```{r}
#adding distance from goalkeeper and angle to gk
shots_valid_wwc2023_no_corner <- shots_valid_wwc2023_no_corner %>% mutate(opposite = location.x.GK - location.x,
                                                adjacent = location.y.GK - location.y,
                                                hypotenuse = sqrt(opposite^2 + adjacent^2),
                                                angle.to.gk = ifelse(location.y > location.y.GK, 180 - asin(opposite/hypotenuse)*180/3.14, asin(opposite/hypotenuse)*180/3.14),
                                                angle.to.gk = ifelse(location.x > location.x.GK & location.y < location.y.GK, 270 - asin(opposite/hypotenuse)*180/3.14, angle.to.gk),
                                                distance.to.gk = hypotenuse,
                                                gk.to.goalline = sqrt((120 - location.x.GK)^2 + (40 - location.y.GK)^2)) %>%
                                                  select(-c(opposite, adjacent, hypotenuse))
```

```{r}
# there are a lot of columns with NA that are logical boolean values so replace with FALSE

logical.vars = names(Filter(is.logical, shots_valid_wwc2023_no_corner))

df <- shots_valid_wwc2023_no_corner[logical.vars]
df[is.na(df)] = FALSE
shots_valid_wwc2023_no_corner[logical.vars] = df

```


```{r}
# choose independent variables
ind.vars = c("id", "is.goal", 'distance.to.gk', 'DistToGoal', 'angle.to.gk', 'angle.to.goal', 'gk.to.goalline', 'play_pattern.name','shot.body_part.name', 'shot.type.name', 'shot.technique.name')
```

```{r}
library(caret) 
library(tidyverse)

shots.varsdata = subset(shots_valid_wwc2023_no_corner, select = ind.vars) %>%
  drop_na() %>%
  filter(play_pattern.name != "Other")


#splitting into test train
idx = createDataPartition(shots.varsdata$is.goal, p = 0.8, list = F)
train = shots.varsdata[idx,]
test = shots.varsdata[-idx,]
```

```{r}
training_xg <- shots.varsdata$shot.statsbomb_xg[idx]

training_xg

test_xg <- subset(shots_valid_wwc2023_no_corner, select = c(ind.vars, 'shot.statsbomb_xg')) %>%
  drop_na()
```


```{r}
# random forest ml model 
# with metric being Accuracy 
vars <-  ncol(model.matrix(is.goal ~ ., train[,!colnames(train) %in% c("id")])) - 2

grid <-  expand.grid(mtry = 4:vars)

# five folds with cross validation 
control <- trainControl(classProbs = TRUE, method = "cv", number = 5,
                       allowParallel = T, summaryFunction = prSummary, savePredictions = T)

rf.1_no_corner <- train(is.goal ~ .,
                    data = train[,!colnames(train) %in% c("id")], 
                    method = "rf",
                    metric = "Accuracy", # looking at highest accuracy for metric
                    trControl = control,
                    tuneGrid = grid,
                    preProcess = c("center", "scale"))

print(rf.1_no_corner)

```

```{r}
# predictions for test set
xG_test.rf.1_no_corner <- predict(rf.1_no_corner, test, type = "prob")
```

```{r}
# adding probability of xG to dataset using the random forest model1 
shots.varsdata$my.xG <- predict(rf.1_no_corner, newdata = shots.varsdata, type = "prob")
```

```{r}
# confusion matrix
confusionMatrix(rf.1_no_corner)
```
- We see that the accuracy is 91.58%

```{r}
# Plot 
plot(rf.1_no_corner)
```

```{r}
# see how many mtry the model uses
rf.1_no_corner$bestTune$mtry
```
- The selected model uses 4 randomly selected predictors for the highest accuracy

```{r}
# feature importance 
varImp(rf.1_no_corner)
```
We see that DistToGoal and distance.to.gk are important features in the model (100% and 82.12% respectively)

```{r}
shots_valid_wwc2023_no_corner <- left_join(shots_valid_wwc2023_no_corner, shots.varsdata[,c("id", "my.xG")], by = "id")
```

```{r}
# shot map showing my model's xG for the 2023 WWC without Republic of Ireland's goal from corner
a3 = pitch + geom_point(data = shots_valid_wwc2023_no_corner, aes(x = location.x, y = location.y, color = my.xG$Goal)) + labs(color = "xG", title = "Expected Goals Model Women's World Cup 2023")

a3
```

```{r}
# shot map with goals without Republic Ireland's goal from corner
a4 = pitch_2 + geom_point(data = shots_valid_wwc2023_no_corner, aes(x = location.x, y = location.y, size = my.xG$Goal)) + labs(size = "xG", caption = "Removed Republic of Ireland's goal directly from corner", title = "Expected Goals Model Women's World Cup 2023")

a4
```

```{r}
# adding stroke to the points to add border
# figure out how to add shot result
a5 = pitch + geom_point(data = shots_valid_wwc2023_no_corner, aes(x = location.x, y = location.y, size = my.xG$Goal, stroke = 0.5, alpha = 0.2, color = is.goal)) + labs(size = "xG", caption = "Removed Republic of Ireland's goal directly from corner", title = "Expected Goals Model Women's World Cup 2023")

a5
```

```{r}
# shot map with goals without Republic Ireland's goal from corner
a6 = pitch + geom_point(data = shots_valid_wwc2023_no_corner, aes(x = location.x, y = location.y, size = my.xG$Goal)) + labs(size = "xG", caption = "Removed Republic of Ireland's goal directly from corner", title = "Expected Goals Model Women's World Cup 2023")

a6
```

```{r}
# using open point shape to include stroke and color to the shot map
# stroke argument needs numeric variables

shots_valid_wwc2023_no_corner <- shots_valid_wwc2023_no_corner %>%
  mutate(is.goal_numeric = if_else(is.goal == "Goal", 1.5, 0.5))

a7 = pitch + geom_point(data = shots_valid_wwc2023_no_corner, aes(x = location.x, y = location.y, color = my.xG$Goal, stroke = is.goal_numeric), shape = 1, size = 2) + labs(color = "xG", caption = "Removed Republic of Ireland's goal directly from corner; Darker circles mean goal was scored", title = "Expected Goals Model WWC 2023")

a7
```

```{r}
a7 = pitch + geom_point(data = shots_valid_wwc2023_no_corner, 
                        aes(x = location.x, y = location.y, color = my.xG$Goal, 
                        linetype = is.goal), 
                        shape = 1)

a7
```




Individual players:

```{r}
library(dplyr)
# player shots
player_shots <- shots_valid_wwc2023_no_corner %>%
  group_by(player.name) %>%
  tally(name = "total_shots")
```

```{r}
# player goals
player_goals <- shots_valid_wwc2023_no_corner %>%
  filter(is.goal == "Goal") %>%
  group_by(player.name) %>%
  tally(name = "Goals", sort = TRUE)
```

```{r}
player_xg <- shots_valid_wwc2023_no_corner %>%
  group_by(player.name) %>%
  tally(my.xG$Goal, name = "total_xg", sort = TRUE) %>%
  top_n(10)
```

```{r}
summary_data <- left_join(player_xg, player_shots, by = "player.name") %>%
  mutate(xg_per_shot = sprintf("%0.2f", total_xg/total_shots))

summary_data <- left_join(summary_data, player_goals, by = "player.name")
```


```{r, warning = FALSE, message = FALSE}
library(ggsoccer)
players_data <- shots_valid_wwc2023_no_corner %>%
  filter(player.name %in% c("Amanda Ilestedt",
                            "Jennifer Hermoso Fuentes",
                            "Jill Roord",
                            "Hinata Miyazawa",
                            "Lauren Hemp",
                            "Alba María Redondo Ferrer",
                            "Kadidiatou Diani",
                            "Eugénie Le Sommer",
                            "Aitana Bonmati Conca",
                            "Hayley Emma Raso"))

 ggplot() + annotate_pitch(dimensions = pitch_statsbomb) + theme_pitch() + coord_flip(xlim = c(55, 120), ylim = c(-12, 105)) + geom_point(data = players_data, aes(x = location.x, y = location.y, size = my.xG$Goal, color = shot.outcome.name == "Goal")) + facet_wrap(~player.name) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 65, y = 15, label = paste0("xG Total: ", round(total_xg), digits = 2))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 55, y = 15, label = paste0("xG Per Shot: ", xg_per_shot))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 65, y = 65, label = paste0("Goals: ", Goals))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 55, y = 65, label = paste0("Total Shots: ", total_shots))) + labs(title = "Top 10 Players Total xG WWC 2023", color = "Goal", size = "xG")
```

```{r, warning = FALSE, message = FALSE}
# using stroke now and thicker border on the points means goal was scored
library(ggsoccer)
players_data <- shots_valid_wwc2023_no_corner %>%
  filter(player.name %in% c("Amanda Ilestedt",
                            "Jennifer Hermoso Fuentes",
                            "Jill Roord",
                            "Hinata Miyazawa",
                            "Lauren Hemp",
                            "Alba María Redondo Ferrer",
                            "Kadidiatou Diani",
                            "Eugénie Le Sommer",
                            "Aitana Bonmati Conca",
                            "Hayley Emma Raso"))

 ggplot() + annotate_pitch(dimensions = pitch_statsbomb) + theme_pitch() + coord_flip(xlim = c(55, 120), ylim = c(-12, 105)) + geom_point(data = players_data, aes(x = location.x, y = location.y, color = my.xG$Goal, stroke = is.goal_numeric), shape = 1, size = 1.5) + facet_wrap(~player.name) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 65, y = 15, label = paste0("xG Total: ", round(total_xg), digits = 2))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 55, y = 15, label = paste0("xG Per Shot: ", xg_per_shot))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 65, y = 65, label = paste0("Goals: ", Goals))) + geom_label(data = summary_data, size = 3, color = "black", aes(x = 55, y = 65, label = paste0("Total Shots: ", total_shots))) + labs(title = "Top 10 Players Total xG WWC 2023", stroke = "Goal", color = "xG")

```
 
Suggestions: Use Plotly to click on point and see which game the shot was from:


```{r}
shots_valid_opponent <- shots_valid_wwc2023_no_corner %>%
  select(id, )
  
```

